---
title: "Building a GitHub Blog in. a Weekend with AWS Kiro"
excerpt: "Spec-driven development meets autonomous AI coding — building a production-grade Next.js site with minimal manual coding."
author: yoonjin-hwang
publishedAt: '2025-07-20T13:30:13.774Z'
updatedAt: '2025-07-20T13:30:13.774Z'
tags: ["Next.js", "CI/CD", "React", "AI"]
featuredImage: "/images/blogs/aws-kiro-github-pages/https---dev-to-uploads.s3.amazonaws.com-uploads-articles-g0qra9dwmnzyp2pwzu3m.png.webp"
status: published
---

Last weekend, I set out to build and deploy a technical blog with a bold constraint: write as little code as possible — and let AWS Kiro do the rest.

Kiro is AWS's new AI development assistant, and unlike most autocomplete or chat-based tools, it positions itself as an autonomous software engineer. I wanted to put that claim to the test.

So I spun up a simple idea: a multilingual, statically generated blog built with Next.js and deployed on GitHub Pages. The catch? I'd rely entirely on Kiro to architect, implement, and ship it.

---

## What is AWS Kiro?

Kiro takes a spec-first approach to software development. Instead of manually coding features, you define high-level goals and requirements. Kiro then drafts specs, derives implementation plans, generates code, and manages the development process step by step — all within its own agent interface.

I decided to lean into that model fully. No CLI scaffolding tools. No external AI wrappers. Just me and Kiro.

---

## Step 1: Define the Stack and Project Goals

The onboarding experience with Kiro feels a lot like briefing a new teammate. It asks about your goals, the tech stack you’d like to use, deployment targets, and constraints.

Here’s the stack I provided:

- **Framework**: Next.js 15+
- **Styling**: Tailwind CSS
- **UI Library**: shadcn/ui
- **Language**: TypeScript

![Defining stack with Kiro](/images/blogs/aws-kiro-github-pages/Screenshot%202025-07-19%20at%209.04.07%E2%80%AFAM.png)
<center>Kiro’s Agent Steering interface used to define architectural guidelines</center>

---

## Step 2: Spec-Driven Development

Kiro translates vague product needs into detailed, testable requirements. For example, a fuzzy goal like “let teammates write and share blog posts” becomes a concrete, behavior-driven user story:

> **Requirement: Blog Post Authoring & Publishing**
> 
> **User Story:** As a team member, I want to author and publish blog posts so I can share technical knowledge.
>
> **Acceptance Criteria:**
> 1. WHEN I open the admin interface, THEN I should see a rich text editor for drafting posts.
> 2. WHEN composing a post, THEN I should be able to set a title, body, tags, and author info.
> 3. ...

This kind of structure brings consistency to every part of the project. It also makes it easier to change direction later — more on that below.

---

## Step 3: Architectural Planning, Automatically

![Architecture generated by Kiro](/images/blogs/aws-kiro-github-pages/mermaid-diagram.svg)

Once the specs are confirmed, Kiro generates a complete design doc: system architecture, component hierarchy, database schema, and implementation roadmap — all mapped to the requirements.

![Generated task plan](/images/blogs/aws-kiro-github-pages/Screenshot%202025-07-19%20at%2010.54.52%E2%80%AFAM.png)
<center>Kiro auto-generates implementation tasks from spec definitions</center>

Because everything flows from specs, the resulting codebase is highly consistent. Unlike typical AI-generated code that can be disjointed, Kiro maintains coherence across files and features — a major improvement over prompt-driven tools.

---

## Step 4: Sit Back and Let Kiro Code

With the plan set, Kiro’s agent begins executing tasks autonomously — generating files, running commands, and building out the project.

![Kiro coding session](/images/blogs/aws-kiro-github-pages/Jul-19-2025%2011-29-20.gif)
<center>Kiro actively creating files and executing shell commands</center>

While the AI worked, I took the opportunity to review its implementation choices and learn about some new libraries it introduced.

Kiro currently uses models like Claude 3.7 Sonnet and GPT-4o under the hood. While still in preview, its responsiveness was generally solid — though traffic spikes occasionally introduced slowdowns or token limits.

![Task progression](/images/blogs/aws-kiro-github-pages/Screenshot%202025-07-19%20at%2011.30.56%E2%80%AFAM.png)
<center>Progress updates after each completed task</center>

---

## The Result: A Fully Functional Tech Blog in Two Days

By Sunday evening, I had a feature-rich technical blog up and running, with most of the work handled by Kiro.

Key features shipped:

- Static site generation (SSG) with Next.js 15
- GitHub Pages CI/CD deployment
- Korean & English language support
- Responsive dark/light theme
- MDX post authoring with syntax highlighting
- Dynamic OG image generation
- Admin dashboard for post creation

![Korean blog version](/images/blogs/aws-kiro-github-pages/Screenshot%202025-07-19%20at%203.45.15%E2%80%AFPM.png)
<center>Main page (Korean)</center>

![English blog version](/images/blogs/aws-kiro-github-pages/Screenshot%202025-07-19%20at%203.45.21%E2%80%AFPM.png)
<center>Main page (English)</center>

![Feature demo](/images/blogs/aws-kiro-github-pages/features.gif)
<center>Browsing post and project lists</center>

---

## Final Thoughts: A Glimpse into the Future of Dev

Kiro doesn’t just autocomplete code — it redefines the development workflow. Where traditional AI tools feel like copilots, Kiro is more like an autonomous engineer you pair with.

The biggest shift was mental: I spent less time writing code, and more time refining requirements and architecture. Changing direction was easy — just update the spec, and Kiro recalibrates its tasks and code accordingly.

It’s still early days. Model latency, task caps, and some execution rough edges show that this is very much a preview. But the foundation is strong.

---

## What’s Left to Ship

Due to usage limits, a few features remain unimplemented:

- Error handling and loading states
- Privacy policy and analytics consent
- Testing suite (unit, integration, E2E)
- Bundle size and performance optimization
- Monitoring for production deployments

I plan to finish the project by watching how Kiro tackles these next.

---

## Wrapping Up

My weekend with AWS Kiro left me genuinely optimistic. It’s not just a tool — it’s a different paradigm.

Spec-driven AI development shifts our focus from writing code to designing systems. And when it works well, it feels like magic: describe what you want, and watch it come to life.

If you get the chance, I highly recommend giving it a try.

---